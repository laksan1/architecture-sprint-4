# Задание 1. Анализ, идентификация проблем и решений, планирование

## 1. Планирование: анализ, идентификация проблем и поиск решений

# 1. Проблемы в архитектуре и инфраструктуре

1.  **Ограниченная масштабируемость**

    - Каждый сервис работает на одном инстансе EC2, что может приводить к узким местам при увеличении нагрузки.
    - Отсутствие балансировки нагрузки между экземплярами.
    - Каждое приложение имеет по одному инстансу.

2.  **База данных с единственным инстансом**

    - Высокая нагрузка на единственный инстанс БД, что может замедлять обработку заказов.
    - Возможные проблемы с отказоустойчивостью при сбоях в базе данных.
    - Одна общая база данных для customers, orders (Shop DB).
    - Одна общая база данных для orders, operations, statuses (MES DB).
    - Отсутствие разделения базы данных на домены.

3.  **Долгий расчёт стоимости заказа в MES**

    - Обработка сложных моделей занимает до 30 минут, что сильно замедляет процесс подтверждения заказа.
    - Нет механизма асинхронного обновления статуса заказа для пользователей.

#### 2. Проблемы с обработкой заказов

1.  **Рост задержек в обработке заказов**

    - CRM не справляется с потоком заказов, особенно после открытия API для партнёров.
    - Возможны блокировки или узкие места в RabbitMQ при передаче сообщений между системами.
    - Просрочка заказов у клиентов.

2.  **Проблемы с API и интеграцией внешних заказов**

    - Рост жалоб со стороны партнёров указывает на перебои в обработке заказов.
    - Возможны тайм-ауты или потери сообщений в RabbitMQ.
    - Отсутствие Kafka при взаимодействии внешних пользователей с MES API.

3.  **Неоптимальная маршрутизация сообщений**

    - Взаимодействие MES и CRM через RabbitMQ может быть недостаточно быстрым или надёжным.
    - Отсутствие приоритезации обработки критически важных сообщений.

#### 3. Проблемы пользовательского интерфейса и UX

1.  **Задержки загрузки дашборда MES**

    - Даже с пагинацией и фильтрацией страница загружается медленно.
    - Возможна неоптимальная работа с базой данных (например, тяжёлые запросы или отсутствие индексов).
    - Долгая первоначальная загрузка страницы MES системы (дашборд с фильтром).

2.  **Отсутствие отображения актуального статуса заказов для клиентов**

    - Пользователи не получают своевременные обновления о статусе своих заказов, что ведёт к росту жалоб.
    - Отсутствие кэша.

#### 4. Проблемы CI/CD и разработки

1.  **Задержки релизов из-за ручного тестирования**

    - QA-инженеры проводят тестирование вручную, что замедляет выпуск новых версий.
    - Увеличение количества багов high и highest усложняет релизный процесс.
    - Долгое тестирование, вызванное проверкой всего монолита приложения.
    - При добавлении новой фичи в монолит тестируется всё приложение.
    - Отсутствие микросервисной архитектуры.
    - Отсутствие автоматизации для E2E тестирования.

2.  **Ручной деплой в release и prod**

- Это увеличивает время вывода исправлений на продакшн и снижает гибкость команды.
- Возможно, разные среды выполнения для деплоя dev, release, prod.

3.  **Отказоустойчивость системы**

- Нет разделения монолита.
- Нет микросервисной архитектуры.
- Нет балансировщика.
- Отсутствие CircuitBreaker (систему можно положить запросами с ошибками).

#### 5. Проблемы с аналитикой и управлением данными

1.  **Отсутствие аналитики (аналитиков)**

- Нет системы сбора метрик и логирования ключевых показателей работы приложения.
- Отсутствие дашбордов и визуализации данных для мониторинга эффективности работы CRM и MES.
- Нет данных для предсказания загрузки системы и планирования масштабирования.

---

# Инициативы в порядке приоритета

## 1. Оптимизация загрузки первой страницы товаров (ускорение начальной загрузки)

**Цель**: Уменьшить время первой загрузки страницы товаров для пользователей.

### Как:

- **Lazy loading**: Загрузка товаров по мере прокрутки страницы или загрузка только необходимого набора данных на первой странице.
- **Кэширование запросов**: Использование кэширования для повторно запрашиваемых данных (например, кэширование товаров на странице).
- **Индексация запросов**: Добавление индексов на наиболее часто используемые поля в базе данных (категория товаров, цена, наличие на складе).
- **Server-Side Rendering (SSR)**: Ускорение первой загрузки страницы с помощью SSR для быстрой отрисовки контента на сервере.
- **API оптимизация**: Уменьшение объема передаваемых данных за счет фильтрации и пагинации на стороне сервера.

---

## 2. Внедрение Kafka для обработки сообщений между сервисами

**Цель**: Устранение узких мест RabbitMQ, повышение отказоустойчивости и надежности системы.

### Как:

Использование Kafka для обработки сообщений с гарантией доставки и масштабирования системы для большего числа пользователей и заказов.

### Преимущества:

- Улучшение скорости обработки заказов.
- Снижение потерь сообщений.
- Повышенная отказоустойчивость.

---

## 3. Оптимизация MES-системы

**Цель**: Ускорить работу MES и улучшить эффективность обработки заказов.

### Как:

- **Асинхронная обработка**: Использование асинхронных методов для расчёта стоимости и обработки операций.
- **Кэширование статусов заказов**: Введение кэширования данных о статусах заказов для ускорения обновления информации.
- **Изменения в базе данных**: Оптимизация структуры БД, добавление индексов на наиболее часто запрашиваемые поля.
- **Управление потоками работы**: Использование **workflow automation** для оптимизации последовательности действий.

---

## 4. Микросервисная архитектура

**Цель**: Разделение монолита на микросервисы для улучшения масштабируемости и отказоустойчивости.

### Как:

Разделение приложения на изолированные сервисы, каждый из которых выполняет одну задачу (например, расчёт стоимости, обработка заказов).

### Преимущества:

- Лёгкость в масштабировании.
- Быстрые деплои.
- Улучшенная тестируемость.

---

## 5. Разделение баз данных по паттерну **Database per Service**

**Цель**: Повышение гибкости и отказоустойчивости системы путем изоляции данных для каждого микросервиса.

### Как:

- Каждый микросервис использует собственную базу данных, которая оптимизирована для его нужд, и не зависит от других сервисов.
- Это разделение позволяет избежать блокировок и проблем с производительностью, возникающих при совместном доступе к единой базе данных (**_Pooling database transactions_**).
- Каждый сервис имеет полный контроль над своей базой данных, что упрощает обновления и миграции без влияния на другие части системы.

### Преимущества:

- **Масштабируемость**: Легче масштабировать сервисы, так как каждый сервис управляет своей собственной базой данных.
- **Изоляция**: Отказ одного сервиса или его базы данных не повлияет на другие сервисы.
- **Технологическая независимость**: Возможность выбора наиболее подходящей базы данных для каждого сервиса (например, SQL для одного и NoSQL для другого).
- **Производительность**: Минимизация проблем с конкуренцией и блокировками при доступе к данным.

### Паттерн: **Database per Service** помогает повысить гибкость и снижает зависимость между сервисами, что важно для сложных распределенных систем.

---

## 6. Использование Feature Toggles для безопасного тестирования фич

**Цель**: Безопасное включение и тестирование новых функциональностей без влияния на стабильность системы.

### Как:

Внедрение **Feature Toggles** позволит включать/отключать фичи в реальном времени без необходимости деплоя новой версии.

### Преимущества:

- Уменьшение рисков при внедрении новых фич.
- Гибкость в управлении функциями.

---

## 7. Автоматизация тестирования (юнит-тесты, интеграционные, E2E)

**Цель**: Повышение качества релизов через автоматизацию тестирования.

### Как:

Внедрение автоматических тестов для:

- Юнит-тестов (для отдельных компонентов).
- Интеграционных тестов (для проверки взаимодействий).
- E2E тестов (для проверки всей цепочки процессов).

### Преимущества:

- Снижение ошибок в коде.
- Ускорение выпуска новых фич.
- Повышение качества продукта.

---

## 8. Интеграция системы аналитики и мониторинга

**Цель**: Обеспечение контроля над производительностью системы и точности данных.

### Как:

- Внедрение инструментов для сбора метрик (Prometheus, Grafana, ELK stack) или APM системы Dynatrace.
- Создание дашбордов для визуализации производительности и состояния системы.
- Применение предсказательной аналитики для планирования масштабирования.
- Сделать отдельный MS Аналитики с CLickHouse

---

## 9. Оптимизация маршрутизации сообщений между сервисами

**Цель**: Ускорение взаимодействия между сервисами и повышение их надежности.

### Как:

- Использование более оптимальных механизмов маршрутизации сообщений.
- Внедрение приоритезации сообщений для быстрой обработки критичных задач.
- Разделение маршрутизации на категории по важности (например, для критичных сообщений — приоритетные очереди).

---

## 10. Автоматизация CI/CD (релизы, депорй и TTM (Time To Market))

**Цель**: Ускорение и автоматизация процессов деплоя и выпуска новых версий.

### Как:

Внедрение автоматических пайплайнов для сборки, тестирования и деплоя с использованием инструментов, таких как Jenkins, GitLab CI, CircleCI.

### Преимущества:

- Быстрые и надёжные релизы.
- Меньше ошибок из-за человеческого фактора.

---

## 11. Интеграция с Kafka и распределенные транзакции

**Цель**: Увеличение пропускной способности системы через эффективный обмен сообщениями между компонентами через Kafka.

### Как:

Использование Kafka для поддержания транзакционности и отказоустойчивости в распределённых системах.

## 12. Отказоустойчивость и управление нагрузкой

### **Паттерн Circuit Breaker**

**Цель**: Повышение отказоустойчивости системы путем предотвращения повторных неудачных попыток обращения к неработающим сервисам.

#### Как:

- Использование **Circuit Breaker** для управления состоянием внешних сервисов и внутренних компонентов, которые могут выйти из строя.
- При слишком большом количестве неудачных попыток сервис "перерывает цепь", что предотвращает дальнейшие попытки до восстановления сервиса.
- В зависимости от состояния (закрыта/открыта/полузакрыта) может направлять запросы на альтернативные ресурсы или возвращать предсказуемые ответы.

#### Преимущества:

- **Защита от фаллов**: Избегание дальнейших ошибок и нагрузок на сервисы, которые уже находятся в сбое.
- **Управляемость сбоев**: Плавное восстановление после сбоев за счет постепенного включения компонента в систему.
- **Управление отказами**: Повышение стабильности системы в условиях высокой нагрузки.

---

### **Паттерн Rate Limiting**

**Цель**: Ограничение количества запросов на единицу времени для защиты сервиса от перегрузки.

#### Как:

- Внедрение **Rate Limiting** для ограничения количества запросов, которые могут быть обработаны сервисом за определенный промежуток времени.
- Настройка лимитов на количество запросов в минуту/секунду и использование механизмов очередей и отклонений запросов.

#### Преимущества:

- **Предотвращение перегрузки**: Снижение риска отказов из-за чрезмерных нагрузок.
- **Справедливая нагрузка**: Уменьшение приоритета запросов с высокой частотой, что позволяет равномерно распределять ресурсы среди пользователей.

### Преимущества:

- Высокая пропускная способность.
- Снижение времени задержки при обмене сообщениями между сервисами.

---

## Планирование

## 1. Целевая архитектура через полгода

Целевая архитектура через полгода будет включать следующие ключевые элементы:

- **Микросервисная архитектура с изоляцией данных**:

  - Система будет разделена на несколько микросервисов, каждый из которых будет иметь свою собственную базу данных (паттерн **Database per Service**). Это обеспечит масштабируемость, независимость и отказоустойчивость.
  - Каждый сервис будет независимым, с возможностью использования разных технологий для БД (например, SQL для одного, NoSQL для другого), что повысит гибкость системы.

- **Kafka как основное средство обмена сообщениями**:

  - Kafka будет использоваться для обработки сообщений и обмена данными между сервисами, что обеспечит отказоустойчивость и простоту коммуникации.

- **Оптимизация производительности и времени отклика**:

  - Использование **Lazy Loading**, кэширование данных, оптимизация API-запросов для улучшения пользовательского опыта и времени отклика системы.

- **Автоматизация тестирования и CI/CD пайплайнов**:

  - Внедрение автоматических тестов (юнит-тесты, интеграционные тесты, E2E) и автоматизация CI/CD процессов для ускорения развертывания и релизов.

- **Инструменты мониторинга и аналитики**:
  - Внедрение систем мониторинга (например, Prometheus, Grafana) для быстрого реагирования на сбои и проблем с производительностью.

## 2. Порядок приоритетов для инициатив

На основе анализа текущей ситуации и целевой архитектуры, порядок приоритетов для инициатив:

1. **Микросервисная архитектура и паттерн Database per Service**:

2. **Интеграция с Kafka**:

3. **Оптимизация загрузки страниц (Lazy loading, кэширование)**:

4. **Автоматизация тестирования и CI/CD**:

5. **Отказоустойчивость и управление нагрузкой (Circuit Breaker, Rate Limiting)**:

6. **Интеграция системы аналитики и мониторинга**:

## 3. Три инициативы на ближайшие полгода

Если бы было возможно выполнить только три инициативы за ближайшие полгода, то это были бы:

1. **Микросервисная архитектура и Database per Service**:

   - Это основа для всех будущих изменений. Микросервисы и разделение баз данных на независимые сервисы обеспечат гибкость, отказоустойчивость и масштабируемость системы, что крайне важно для ее роста.

2. **Интеграция с Kafka**:

   - Kafka поможет эффективно обмениваться сообщениями и обеспечит отказоустойчивость. Это критичный шаг для увеличения масштабируемости системы, особенно при высоких нагрузках.

3. **Оптимизация загрузки страниц (Lazy Loading, кэширование)**:
   - Ускорение работы системы и улучшение времени отклика положительно скажется на пользовательском опыте и производительности системы, что даст заметный эффект на начальных этапах внедрения.

### Почему именно эти три инициативы?

- **Микросервисная архитектура и Database per Service** создаст прочную основу для дальнейшего роста системы.
- **Интеграция с Kafka** улучшит обмен данными между сервисами, обеспечивая отказоустойчивость и масштабируемость.
- **Оптимизация загрузки страниц** напрямую повлияет на качество взаимодействия с пользователями, улучшив их опыт и снижая нагрузку на систему.
